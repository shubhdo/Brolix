/* eslint no-path-concat: 0 */
var Promise = require('bluebird')
var path = require('path')
var fs = require('fs')
var readFileAsync = Promise.promisify(fs.readFile)
var writeFileAsync = Promise.promisify(fs.writeFile)
var request = require('request')
var hostname = require('os').hostname()
var crypto = require('crypto')
var hostId = crypto.createHash('sha1').update(hostname + __dirname).digest('hex')
var mkdirpAsync = Promise.promisify(require('mkdirp'))
var objectAssign = require('object-assign')

function verifyLicenseKey (reporter, definition, key) {
  var trimmedKey = key.trim()
  reporter.logger.info('Verifying license key ' + trimmedKey)

  return reporter.documentStore.collection('templates').count({}).then(function (count) {
    return processVerification(reporter, definition, {
      licenseKey: trimmedKey,
      mode: reporter.options.mode,
      numberOfTemplates: count,
      version: reporter.version,
      hostId: hostId
    })
  })
}

function processVerification (reporter, definition, m) {
  var licenseInfoPath = path.join(reporter.options.rootDirectory, 'license.json')

  if (!fs.existsSync(licenseInfoPath) || definition.options.useSavedLicenseInfo === false) {
    if (m.licenseKey === 'free' && m.numberOfTemplates <= 5) {
      definition.options.license = definition.options.type = 'free'
      return reporter.logger.info('Using free license')
    }

    // the license info is not verified, need to perform remote check for enterprise licenses
    return verifyInService(reporter, definition, m, licenseInfoPath)
  }

  return fs.readFileAsync(licenseInfoPath, 'utf8').catch(function () {
    return false
  }).then(function (l) {
    if (l === false) {
      reporter.logger.warn('Failed to read the license.json, processing remote license verification')
      return verifyInService(reporter, definition, m, licenseInfoPath)
    }

    var storedLicense = JSON.parse(l)

    // the license.json needs to contain valid hash to prevent user's manual file changes
    var hash = storedLicense.securityHash
    delete storedLicense.securityHash
    if (hash !== crypto.createHash('sha1').update(JSON.stringify(storedLicense)).digest('hex')) {
      reporter.logger.warn('License info stored in license.json is corrupted, processing remote license verification')
      return verifyInService(reporter, definition, m, licenseInfoPath)
    }

    if (storedLicense.licenseKey !== m.licenseKey) {
      reporter.logger.info('License key being verified and license key stored in license.json doesn\'t match, processing remote license verification')

      // the user should be able to perform remote verification and then copy license.json with app
      // no need to set somewhere the license key again, because the license key from license.json will be used
      if (m.licenseKey === 'free') {
        m.licenseKey = storedLicense.licenseKey
      }

      return verifyInService(reporter, definition, m, licenseInfoPath)
    }

    if (storedLicense.type === 'subscription') {
      if (new Date(storedLicense.expiresOn) < new Date()) {
        reporter.logger.info('License info stored in license.json is no longer valid, processing remote license verification')
        return verifyInService(reporter, definition, m, licenseInfoPath)
      }

      definition.options = storedLicense
      return reporter.logger.info('License key for subscription verified against the license.json file')
    }

    if (storedLicense.validatedForVersion === reporter.version) {
      definition.options = storedLicense
      return reporter.logger.info('License key for perpetual license verified against license.json file')
    } else {
      reporter.logger.info('The already verified instance version stored in license.json doesn\'t match with the current jsreport version, processing remote license verification')
      return verifyInService(reporter, definition, m, licenseInfoPath)
    }
  })
}

function verifyInService (reporter, definition, m, licenseInfoPath) {
  // developers often keeps jsreport instances to auto restart inifinitely
  // in case of invalid license key this bombards constantly our validation server
  // for this case we cache the invalid license keys for short time to avoid this
  return isLicenseKeyStoredInNegativeCache(reporter, m.licenseKey).then(function (cachedNegativeResponse) {
    if (cachedNegativeResponse) {
      reporter.logger.debug('The recent negative cache validation was used to stop jsreport')
      closeWebServer(reporter)
      throw new Error(cachedNegativeResponse)
    }

    return new Promise(function (resolve, reject) {
      var isDone = false

      function handleFailedVerification () {
        isDone = true

        reporter.logger.info('The licensing server was not reachable during instance startup. The instance now runs in the enterprise mode.')
        definition.options = {
          license: 'enterprise',
          unreachable: true
        }
        resolve()
      }

      // to avoid startup delays we have quite small timeout to perform remote validation
      // in some networks it takes long time to find out that the remote server is actually not reacheble
      var timeout = setTimeout(handleFailedVerification, 3000).unref()

      request({
        url: 'https://jsreportonline.net/license-key',
        method: 'POST',
        body: m,
        json: true
      }, function (err, response, body) {
        if (isDone) {
          return
        }
        clearTimeout(timeout)

        // something went wrong during remote validation, this likely doesn't indicate the wrong license key so we start as with valid license
        if (err || response.statusCode !== 200 || !Number.isInteger(body.status)) {
          return handleFailedVerification()
        }

        // the remote validator rejected the license key, the jsreport instance should fail to start
        if (body.status === 1) {
          return writeLicenseKeyToNegativeCache(reporter, m.licenseKey, body.message).then(function () {
            closeWebServer(reporter)
            reject(new Error(body.message))
          })
        }

        reporter.logger.info(body.message)

        objectAssign(definition.options, body, {
          validatedForVersion: reporter.version
        })

        // persist the license.json only in case of valid enterprise license which is not expiring
        if (body.type !== 'trial' && body.type !== 'free' && definition.options.useSavedLicenseInfo !== false) {
          reporter.logger.info('Storing license verification information to license.json')
          definition.options.licenseInfoSaved = true

          var licensingInfo = {
            licenseKey: m.licenseKey,
            validatedForVersion: reporter.version,
            expiresOn: body.expiresOn,
            license: body.license,
            type: body.type
          }

          licensingInfo.securityHash = crypto.createHash('sha1').update(JSON.stringify(licensingInfo)).digest('hex')

          return writeFileAsync(licenseInfoPath, JSON.stringify(licensingInfo, null, 4), 'utf8').catch(function (e) {
            definition.options.licenseInfoSaved = false
            reporter.logger.warn('Unable to write verified license info to license.json, the remote verification will be performed again during the next instance start: ' + e)
          }).then(function () {
            resolve()
          })
        } else {
          resolve()
        }
      })
    })
  })
}

function isLicenseKeyStoredInNegativeCache (reporter, licenseKey) {
  var licenseCacheFile = path.join(reporter.options.tempDirectory, 'licensing', licenseKey + '.json')

  return mkdirpAsync(path.join(reporter.options.tempDirectory, 'licensing')).then(function () {
    return readFileAsync(licenseCacheFile, 'utf8').then(function (t) {
      var info = JSON.parse(t)

      if (info.version !== reporter.version) {
        return null
      }

      if (new Date(info.lastVerification).getTime() + 60000 < new Date().getTime()) {
        return null
      }

      return info.message
    })
  }).catch(function () {
    // the cache file doesn't need to exist, or have wrong permissions...
    // we don't care about it, in that case the remote validation will take place
    return null
  })
}

function writeLicenseKeyToNegativeCache (reporter, licenseKey, message) {
  var info = JSON.stringify({
    message: message,
    version: reporter.version,
    lastVerification: new Date()
  })

  return writeFileAsync(path.join(reporter.options.tempDirectory, 'licensing', licenseKey + '.json'), info).catch(function () {
  })
}

function closeWebServer (reporter) {
  // otherwise the node process doesn't exit
  if (reporter.express && reporter.express.server) {
    reporter.express.server.close()
  }
}

module.exports = function (reporter, definition) {
  reporter.on('express-configure', function (app) {
    app.post('/api/licensing/trial', function (req, res, next) {
      verifyLicenseKey(reporter, definition, 'free').then(function () {
        res.send({ status: 0 })
      }).catch(function (e) {
        reporter.logger.warn('Unable to start trial license')
        res.send({ status: 1 })
      })
    })
  })

  reporter.initializeListeners.add('licensing', function () {
    if (reporter.options['license-key']) {
      return verifyLicenseKey(reporter, definition, reporter.options['license-key'])
    }

    var licenseKeyPath
    if (fs.existsSync(path.join(reporter.options.rootDirectory, 'license-key.txt'))) {
      licenseKeyPath = path.join(reporter.options.rootDirectory, 'license-key.txt')
    }

    if (fs.existsSync(path.join(reporter.options.dataDirectory, 'license-key.txt'))) {
      licenseKeyPath = path.join(reporter.options.dataDirectory, 'license-key.txt')
    }

    if (licenseKeyPath) {
      return readFileAsync(licenseKeyPath, 'utf8').then(function (key) {
        if (key.charCodeAt(0) === 0xFEFF) {
          key = key.substring(1)
        }
        return verifyLicenseKey(reporter, definition, key.toString())
      })
    }

    return verifyLicenseKey(reporter, definition, 'free')
  })
}
